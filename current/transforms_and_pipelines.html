<!doctype html>
<html class="no-js">
  <head><meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width,initial-scale=1"/>
    <meta name="color-scheme" content="light dark"><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />
<link rel="index" title="Index" href="genindex.html" /><link rel="search" title="Search" href="search.html" /><link rel="next" title="Hyperparameters" href="hyperparams.html" /><link rel="prev" title="Synopsis and overview" href="synopsis.html" />

    <meta name="generator" content="sphinx-4.5.0, furo 2022.09.29"/>
        <title>Transforms and pipelines - 🧟 Frankenfit Documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo.css?digest=d81277517bee4d6b0349d71bb2661d4890b5617c" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    <link rel="stylesheet" type="text/css" href="_static/styles/furo-extensions.css?digest=30d1aed668e5c3a91c3e3bf6a60b675221979f0e" />
    <link rel="stylesheet" type="text/css" href="_static/pygments_overrides.css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments_overrides.css" />
    <link rel="stylesheet" type="text/css" href="_static/pygments_overrides.css" />
    
    


<style>
  body {
    --color-code-background: #282a36;
  --color-code-foreground: #f8f8f2;
  --color-background-item: #6272A4;
  --color-brand-primary: #50FA7B;
  --color-brand-content: #50FA7B;
  --color-problematic: #FF5555;
  --color-foreground-primary: #F8F8F2;
  --color-foreground-secondary: #6272A4;
  --color-foreground-border: #6272A4;
  --color-background-primary: #282A36;
  --color-background-secondary: #343746;
  --color-background-hover: #44475A;
  --color-background-hover--transparent: #44475A;
  --color-highlighted-background: #44475A75;
  --color-admonition-background: #343746;
  --color-admonition-title--caution: #FFB86C;
  --color-admonition-title-background--caution: rgba(255, 184, 108, .1);
  --color-admonition-title--warning: #F1FA8C;
  --color-admonition-title-background--warning: rgba(241, 250, 140, .1);
  --color-admonition-title--danger: #FF5555;
  --color-admonition-title-background--danger: rgba(255, 85, 85, .1);
  --color-admonition-title--attention: #FF5555;
  --color-admonition-title-background--attention: rgba(255, 85, 85, .1);
  --color-admonition-title--error: #FF5555;
  --color-admonition-title-background--error: rgba(255, 85, 85, .1);
  --color-admonition-title--hint: #50FA7B;
  --color-admonition-title-background--hint: rgba(80, 250, 123, .1);
  --color-admonition-title--tip: #50FA7B;
  --color-admonition-title-background--tip: rgba(80, 250, 123, .1);
  --color-admonition-title--important: #FF79C6;
  --color-admonition-title-background--important: rgba(255, 121, 198, .1);
  --color-admonition-title--note: #BD93F9;
  --color-admonition-title-background--note: rgba(189, 147, 249, .1);
  --color-admonition-title--seealso: #6272A4;
  --color-admonition-title-background--seealso: rgba(98, 114, 164, .1);
  --color-admonition-title--admonition-todo: #808080;
  --color-admonition-title-background--admonition-todo: rgba(128, 128, 128, .1);
  
  }
  @media not print {
    body[data-theme="dark"] {
      --color-code-background: #282a36;
  --color-code-foreground: #f8f8f2;
  --color-background-item: #6272A4;
  --color-brand-primary: #50FA7B;
  --color-brand-content: #50FA7B;
  --color-problematic: #FF5555;
  --color-foreground-primary: #F8F8F2;
  --color-foreground-secondary: #6272A4;
  --color-foreground-border: #6272A4;
  --color-background-primary: #282A36;
  --color-background-secondary: #343746;
  --color-background-hover: #44475A;
  --color-background-hover--transparent: #44475A;
  --color-highlighted-background: #44475A75;
  --color-admonition-background: #343746;
  --color-admonition-title--caution: #FFB86C;
  --color-admonition-title-background--caution: rgba(255, 184, 108, .1);
  --color-admonition-title--warning: #F1FA8C;
  --color-admonition-title-background--warning: rgba(241, 250, 140, .1);
  --color-admonition-title--danger: #FF5555;
  --color-admonition-title-background--danger: rgba(255, 85, 85, .1);
  --color-admonition-title--attention: #FF5555;
  --color-admonition-title-background--attention: rgba(255, 85, 85, .1);
  --color-admonition-title--error: #FF5555;
  --color-admonition-title-background--error: rgba(255, 85, 85, .1);
  --color-admonition-title--hint: #50FA7B;
  --color-admonition-title-background--hint: rgba(80, 250, 123, .1);
  --color-admonition-title--tip: #50FA7B;
  --color-admonition-title-background--tip: rgba(80, 250, 123, .1);
  --color-admonition-title--important: #FF79C6;
  --color-admonition-title-background--important: rgba(255, 121, 198, .1);
  --color-admonition-title--note: #BD93F9;
  --color-admonition-title-background--note: rgba(189, 147, 249, .1);
  --color-admonition-title--seealso: #6272A4;
  --color-admonition-title-background--seealso: rgba(98, 114, 164, .1);
  --color-admonition-title--admonition-todo: #808080;
  --color-admonition-title-background--admonition-todo: rgba(128, 128, 128, .1);
  
    }
    @media (prefers-color-scheme: dark) {
      body:not([data-theme="light"]) {
        --color-code-background: #282a36;
  --color-code-foreground: #f8f8f2;
  --color-background-item: #6272A4;
  --color-brand-primary: #50FA7B;
  --color-brand-content: #50FA7B;
  --color-problematic: #FF5555;
  --color-foreground-primary: #F8F8F2;
  --color-foreground-secondary: #6272A4;
  --color-foreground-border: #6272A4;
  --color-background-primary: #282A36;
  --color-background-secondary: #343746;
  --color-background-hover: #44475A;
  --color-background-hover--transparent: #44475A;
  --color-highlighted-background: #44475A75;
  --color-admonition-background: #343746;
  --color-admonition-title--caution: #FFB86C;
  --color-admonition-title-background--caution: rgba(255, 184, 108, .1);
  --color-admonition-title--warning: #F1FA8C;
  --color-admonition-title-background--warning: rgba(241, 250, 140, .1);
  --color-admonition-title--danger: #FF5555;
  --color-admonition-title-background--danger: rgba(255, 85, 85, .1);
  --color-admonition-title--attention: #FF5555;
  --color-admonition-title-background--attention: rgba(255, 85, 85, .1);
  --color-admonition-title--error: #FF5555;
  --color-admonition-title-background--error: rgba(255, 85, 85, .1);
  --color-admonition-title--hint: #50FA7B;
  --color-admonition-title-background--hint: rgba(80, 250, 123, .1);
  --color-admonition-title--tip: #50FA7B;
  --color-admonition-title-background--tip: rgba(80, 250, 123, .1);
  --color-admonition-title--important: #FF79C6;
  --color-admonition-title-background--important: rgba(255, 121, 198, .1);
  --color-admonition-title--note: #BD93F9;
  --color-admonition-title-background--note: rgba(189, 147, 249, .1);
  --color-admonition-title--seealso: #6272A4;
  --color-admonition-title-background--seealso: rgba(98, 114, 164, .1);
  --color-admonition-title--admonition-todo: #808080;
  --color-admonition-title-background--admonition-todo: rgba(128, 128, 128, .1);
  
      }
    }
  }
</style></head>
  <body>
    
    <script>
      document.body.dataset.theme = localStorage.getItem("theme") || "auto";
    </script>
    

<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
  <symbol id="svg-toc" viewBox="0 0 24 24">
    <title>Contents</title>
    <svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 1024 1024">
      <path d="M408 442h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8zm-8 204c0 4.4 3.6 8 8 8h480c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8H408c-4.4 0-8 3.6-8 8v56zm504-486H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 632H120c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h784c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM115.4 518.9L271.7 642c5.8 4.6 14.4.5 14.4-6.9V388.9c0-7.4-8.5-11.5-14.4-6.9L115.4 505.1a8.74 8.74 0 0 0 0 13.8z"/>
    </svg>
  </symbol>
  <symbol id="svg-menu" viewBox="0 0 24 24">
    <title>Menu</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-menu">
      <line x1="3" y1="12" x2="21" y2="12"></line>
      <line x1="3" y1="6" x2="21" y2="6"></line>
      <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
  </symbol>
  <symbol id="svg-arrow-right" viewBox="0 0 24 24">
    <title>Expand</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather-chevron-right">
      <polyline points="9 18 15 12 9 6"></polyline>
    </svg>
  </symbol>
  <symbol id="svg-sun" viewBox="0 0 24 24">
    <title>Light mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="feather-sun">
      <circle cx="12" cy="12" r="5"></circle>
      <line x1="12" y1="1" x2="12" y2="3"></line>
      <line x1="12" y1="21" x2="12" y2="23"></line>
      <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
      <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
      <line x1="1" y1="12" x2="3" y2="12"></line>
      <line x1="21" y1="12" x2="23" y2="12"></line>
      <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
      <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
    </svg>
  </symbol>
  <symbol id="svg-moon" viewBox="0 0 24 24">
    <title>Dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-moon">
      <path stroke="none" d="M0 0h24v24H0z" fill="none" />
      <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
    </svg>
  </symbol>
  <symbol id="svg-sun-half" viewBox="0 0 24 24">
    <title>Auto light/dark mode</title>
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor"
      stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="icon-tabler-shadow">
      <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
      <circle cx="12" cy="12" r="9" />
      <path d="M13 12h5" />
      <path d="M13 15h4" />
      <path d="M13 18h1" />
      <path d="M13 9h4" />
      <path d="M13 6h1" />
    </svg>
  </symbol>
</svg>

<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation">
<input type="checkbox" class="sidebar-toggle" name="__toc" id="__toc">
<label class="overlay sidebar-overlay" for="__navigation">
  <div class="visually-hidden">Hide navigation sidebar</div>
</label>
<label class="overlay toc-overlay" for="__toc">
  <div class="visually-hidden">Hide table of contents sidebar</div>
</label>



<div class="page">
  <header class="mobile-header">
    <div class="header-left">
      <label class="nav-overlay-icon" for="__navigation">
        <div class="visually-hidden">Toggle site navigation sidebar</div>
        <i class="icon"><svg><use href="#svg-menu"></use></svg></i>
      </label>
    </div>
    <div class="header-center">
      <a href="cover.html"><div class="brand">🧟 Frankenfit Documentation</div></a>
    </div>
    <div class="header-right">
      <div class="theme-toggle-container theme-toggle-header">
        <button class="theme-toggle">
          <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
          <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
          <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
          <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
        </button>
      </div>
      <label class="toc-overlay-icon toc-header-icon" for="__toc">
        <div class="visually-hidden">Toggle table of contents sidebar</div>
        <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
      </label>
    </div>
  </header>
  <aside class="sidebar-drawer">
    <div class="sidebar-container">
      
      <div class="sidebar-sticky"><a class="sidebar-brand" href="cover.html">
  
  
  <span class="sidebar-brand-text">🧟 Frankenfit Documentation</span>
  
</a><form class="sidebar-search-container" method="get" action="search.html" role="search">
  <input class="sidebar-search" placeholder=Search name="q" aria-label="Search">
  <input type="hidden" name="check_keywords" value="yes">
  <input type="hidden" name="area" value="default">
</form>
<div id="searchbox"></div><div class="sidebar-scroll"><div class="sidebar-tree">
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation and getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="synopsis.html">Synopsis and overview</a></li>
<li class="toctree-l1 current current-page"><a class="current reference internal" href="#">Transforms and pipelines</a></li>
<li class="toctree-l1"><a class="reference internal" href="hyperparams.html">Hyperparameters</a></li>
<li class="toctree-l1"><a class="reference internal" href="dataframes.html">Working with DataFrames and <code class="docutils literal notranslate"><span class="pre">DataFramePipelines</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="branching_and_grouping.html">Branching and grouping transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="backends.html">Backends and parallel compute</a></li>
<li class="toctree-l1"><a class="reference internal" href="implementing_transforms.html">Implementing your own transforms</a></li>
<li class="toctree-l1"><a class="reference internal" href="crossval.html">Cross-validation and hyperparameter search</a></li>
<li class="toctree-l1"><a class="reference internal" href="tips_tricks.html">Tips and tricks</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">Frankenfit API reference</a></li>
</ul>

</div>
</div>

      </div>
      
    </div>
  </aside>
  <div class="main">
    <div class="content">
      <div class="article-container">
        <a href="#" class="back-to-top muted-link">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12z"></path>
          </svg>
          <span>Back to top</span>
        </a>
        <div class="content-icon-container">
          
<div class="theme-toggle-container theme-toggle-content">
            <button class="theme-toggle">
              <div class="visually-hidden">Toggle Light / Dark / Auto color theme</div>
              <svg class="theme-icon-when-auto"><use href="#svg-sun-half"></use></svg>
              <svg class="theme-icon-when-dark"><use href="#svg-moon"></use></svg>
              <svg class="theme-icon-when-light"><use href="#svg-sun"></use></svg>
            </button>
          </div>
          <label class="toc-overlay-icon toc-content-icon" for="__toc">
            <div class="visually-hidden">Toggle table of contents sidebar</div>
            <i class="icon"><svg><use href="#svg-toc"></use></svg></i>
          </label>
        </div>
        <article role="main">
          <section class="tex2jax_ignore mathjax_ignore" id="transforms-and-pipelines">
<h1>Transforms and pipelines<a class="headerlink" href="#transforms-and-pipelines" title="Permalink to this headline">#</a></h1>
<section id="transforms">
<h2>Transforms<a class="headerlink" href="#transforms" title="Permalink to this headline">#</a></h2>
<p>The basic building blocks of Frankenfit data pipelines are
<strong><a class="reference internal" href="api.html#frankenfit.Transform" title="frankenfit.Transform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Transforms</span></code></span></a>.</strong> Conceptually, each Transform represents a data
manipulation that must first be <strong><a class="reference internal" href="api.html#frankenfit.Transform.fit" title="frankenfit.Transform.fit"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">fit</span></code></span></a></strong> on some
<strong>fitting data</strong>, yielding some <strong>state</strong>, which the user may then
<strong><a class="reference internal" href="api.html#frankenfit.FitTransform.apply" title="frankenfit.FitTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply</span></code></span></a></strong> to transform some <strong>apply data</strong>.</p>
<p>Frankenfit includes an extensive library of built-in Transforms, and ordinarily one will
create instances of these Transforms by using the so-called <a class="reference internal" href="#call-chain-api"><span class="std std-ref">“chall-chain
API”</span></a> provided by <a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a> objects. For
example, a Pipeline (specifically a <a class="reference internal" href="api.html#frankenfit.DataFramePipeline" title="frankenfit.DataFramePipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code></span></a>)
comprising a <a class="reference internal" href="api.html#frankenfit.dataframe.Winsorize" title="frankenfit.dataframe.Winsorize"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Winsorize</span></code></span></a> Transform followed by a
<a class="reference internal" href="api.html#frankenfit.dataframe.DeMean" title="frankenfit.dataframe.DeMean"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DeMean</span></code></span></a> might look like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">frankenfit</span> <span class="k">as</span> <span class="nn">ff</span>

<span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span><span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span><span class="o">.</span><span class="n">de_mean</span><span class="p">();</span>
</pre></div>
</div>
</div>
</div>
<p>However, it is also possible to instantiate Transform objects directly. For example,
Transforms whose fitting data and apply data are meant to be pandas DataFrames are kept
in the module <a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code></span></a>, and we might instantiate the
<code class="docutils literal notranslate"><span class="pre">DeMean</span></code> Transform directly as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DeMean</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<p>Let’s load some data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Load a dataset of diamond prices and covariates</span>
<span class="kn">from</span> <span class="nn">pydataset</span> <span class="kn">import</span> <span class="n">data</span>
<span class="n">diamonds_df</span> <span class="o">=</span> <span class="n">data</span><span class="p">(</span><span class="s2">&quot;diamonds&quot;</span><span class="p">)[[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">]]</span>
<span class="n">diamonds_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>326</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>326</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.23</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>327</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>334</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>335</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">DeMean</span></code> Transform instance <code class="docutils literal notranslate"><span class="pre">dmn</span></code> may then be <strong>fit</strong> on the data. By default it
learns to de-mean all columns in the DataFrame.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_dmn</span> <span class="o">=</span> <span class="n">dmn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The <a class="reference internal" href="api.html#frankenfit.Transform.fit" title="frankenfit.Transform.fit"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></span></a> method returns an instance of
<a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a>, which encapsulates the <strong>state</strong> that was
learned on the fitting data, and which may be <strong>applied</strong> to a dataset by calling its
<a class="reference internal" href="api.html#frankenfit.FitTransform.apply" title="frankenfit.FitTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a> method.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_dmn</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-0.56794</td>
      <td>-0.249405</td>
      <td>-2.457184</td>
      <td>-3606.799722</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.58794</td>
      <td>-1.949405</td>
      <td>3.542816</td>
      <td>-3606.799722</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.56794</td>
      <td>-4.849405</td>
      <td>7.542816</td>
      <td>-3605.799722</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.50794</td>
      <td>0.650595</td>
      <td>0.542816</td>
      <td>-3598.799722</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-0.48794</td>
      <td>1.550595</td>
      <td>0.542816</td>
      <td>-3597.799722</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>In the case of <a class="reference internal" href="api.html#frankenfit.dataframe.DeMean" title="frankenfit.dataframe.DeMean"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DeMean</span></code></span></a>, the state consists of the means
of the columns observed in the fitting data. When applied, it subtracts these means from
the corresponding columns of the apply data, returning the result. Of course, other
Transforms will have totally different kinds of state (e.g., the state of a fit
<a class="reference internal" href="api.html#frankenfit.dataframe.Winsorize" title="frankenfit.dataframe.Winsorize"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Winsorize</span></code></span></a> Transform is the values of the outlier
quantiles observed in the fitting data), and some Transforms may have no state at all
(for example <a class="reference internal" href="api.html#frankenfit.dataframe.ImputeConstant" title="frankenfit.dataframe.ImputeConstant"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ImputeConstant</span></code></span></a> replaces missing
values with a constant that is independent of any fitting data; see <a class="reference internal" href="#stateless-transforms"><span class="std std-ref">Stateless
transforms</span></a>).</p>
<p>One may query the the state of a <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> by calling its
<a class="reference internal" href="api.html#frankenfit.FitTransform.state" title="frankenfit.FitTransform.state"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">state()</span></code></span></a> method. The exact type and value of the state
is an implementation detail of the Transform in question, and in the case of <code class="docutils literal notranslate"><span class="pre">DeMean</span></code> we
can see that its state is a pandas <code class="docutils literal notranslate"><span class="pre">Series</span></code> of means, indexed by column name:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_dmn</span><span class="o">.</span><span class="n">state</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>carat       0.797940
depth      61.749405
table      57.457184
price    3932.799722
dtype: float64
</pre></div>
</div>
</div>
</div>
<p>Crucially, the fitting data and apply data need not be the same. For example, we might
de-mean the dataset with respect to the means observed on some subsample of it:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">diamonds_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="mi">100</span><span class="p">))</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-0.5962</td>
      <td>-0.402</td>
      <td>-2.528</td>
      <td>-3770.36</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.6162</td>
      <td>-2.102</td>
      <td>3.472</td>
      <td>-3770.36</td>
    </tr>
    <tr>
      <th>3</th>
      <td>-0.5962</td>
      <td>-5.002</td>
      <td>7.472</td>
      <td>-3769.36</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.5362</td>
      <td>0.498</td>
      <td>0.472</td>
      <td>-3762.36</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-0.5162</td>
      <td>1.398</td>
      <td>0.472</td>
      <td>-3761.36</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Or we might divide the data into disjoint “training” and “test” sets, feeding the former
to <code class="docutils literal notranslate"><span class="pre">fit()</span></code> and the latter to <code class="docutils literal notranslate"><span class="pre">apply()</span></code>. We call this an <strong>out-of-sample</strong> application of
the Transform.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">train_df</span> <span class="o">=</span> <span class="n">diamonds_df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">frac</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">random_state</span><span class="o">=</span><span class="mi">1337420</span><span class="p">)</span>
<span class="n">test_df</span> <span class="o">=</span> <span class="n">diamonds_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">diamonds_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">train_df</span><span class="o">.</span><span class="n">index</span><span class="p">))]</span>

<span class="n">dmn</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-0.568533</td>
      <td>-0.2537</td>
      <td>-2.457683</td>
      <td>-3608.948906</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-0.588533</td>
      <td>-1.9537</td>
      <td>3.542317</td>
      <td>-3608.948906</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-0.508533</td>
      <td>0.6463</td>
      <td>0.542317</td>
      <td>-3600.948906</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-0.488533</td>
      <td>1.5463</td>
      <td>0.542317</td>
      <td>-3599.948906</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-0.558533</td>
      <td>1.0463</td>
      <td>-0.457683</td>
      <td>-3598.948906</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<section id="parameters">
<h3>Parameters<a class="headerlink" href="#parameters" title="Permalink to this headline">#</a></h3>
<p>Most Transforms have some associated <strong>parameters</strong> that control their behavior. The
values of these parameters are supplied by the user when constructing the Transform
(but as we’ll cover in more detail later, the values may be “hyperparameters” with
deferred evaluation; see <a class="reference internal" href="hyperparams.html"><span class="doc">Hyperparameters</span></a>). Parameters may be required or optional,
typically with some reasonable default value in the latter case.</p>
<p>For example, the <a class="reference internal" href="api.html#frankenfit.dataframe.DeMean" title="frankenfit.dataframe.DeMean"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DeMean</span></code></span></a> Transform that we’ve been using
above has two optional parameters:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">cols</span></code>: A list of the names of the columns to de-mean; by default, all
columns are de-meaned.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">w_col</span></code>: The name of a column to use as a source of observation weights when
computing the means; by default, the means are unweighted.</p></li>
</ul>
<p>Therefore we can define a <code class="docutils literal notranslate"><span class="pre">DeMean</span></code> Transform that only de-means the <code class="docutils literal notranslate"><span class="pre">price</span></code> and <code class="docutils literal notranslate"><span class="pre">table</span></code> columns of the data, or one which de-means <code class="docutils literal notranslate"><span class="pre">price</span></code> with respect to its <code class="docutils literal notranslate"><span class="pre">carat</span></code>-weighted mean:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_2cols</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DeMean</span><span class="p">([</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">])</span>
<span class="n">dmn_2cols</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>-2.457683</td>
      <td>-3608.948906</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>3.542317</td>
      <td>-3608.948906</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>0.542317</td>
      <td>-3600.948906</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>0.542317</td>
      <td>-3599.948906</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.24</td>
      <td>62.8</td>
      <td>-0.457683</td>
      <td>-3598.948906</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_price_weighted</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DeMean</span><span class="p">([</span><span class="s2">&quot;price&quot;</span><span class="p">],</span> <span class="n">w_col</span><span class="o">=</span><span class="s2">&quot;carat&quot;</span><span class="p">)</span>
<span class="n">dmn_price_weighted</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>-5784.919813</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>-5784.919813</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>-5776.919813</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>-5775.919813</td>
    </tr>
    <tr>
      <th>6</th>
      <td>0.24</td>
      <td>62.8</td>
      <td>57.0</td>
      <td>-5774.919813</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>Note that parameters have an order and can generally be specified positionally or by
name. So for example <code class="docutils literal notranslate"><span class="pre">DeMean([&quot;price&quot;,</span> <span class="pre">&quot;table&quot;])</span></code> could also be written as
<code class="docutils literal notranslate"><span class="pre">DeMean(cols=[&quot;price&quot;,</span> <span class="pre">&quot;table&quot;])</span></code>, and <code class="docutils literal notranslate"><span class="pre">DeMean([&quot;price&quot;],</span> <span class="pre">w_col=&quot;carat&quot;)</span></code> could be written as
<code class="docutils literal notranslate"><span class="pre">DeMean([&quot;price&quot;],</span> <span class="pre">&quot;carat&quot;)</span></code> or <code class="docutils literal notranslate"><span class="pre">DeMean(cols=[&quot;price&quot;],</span> <span class="pre">w_col=&quot;carat&quot;)</span></code>.</p>
</div>
<p><a class="reference internal" href="api.html#frankenfit.dataframe.Winsorize" title="frankenfit.dataframe.Winsorize"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Winsorize</span></code></span></a> is an example of a Transform with a
required parameter, <code class="docutils literal notranslate"><span class="pre">limit</span></code>, which specifies the threshold at which extreme values
should be trimmed. It also accepts an optional <code class="docutils literal notranslate"><span class="pre">cols</span></code> parameter, like <code class="docutils literal notranslate"><span class="pre">DeMean</span></code>.</p>
<p>E.g., winsorizing the top and bottom 1% of values in all columns:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mf">0.01</span><span class="p">)</span>
</pre></div>
</div>
<p>Winsorizing just the <code class="docutils literal notranslate"><span class="pre">price</span></code> column’s top and bottom 5% of values:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">])</span>
</pre></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p><code class="docutils literal notranslate"><span class="pre">DeMean</span></code> and <code class="docutils literal notranslate"><span class="pre">Winsorize</span></code> are part of a larger family of <a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref">DataFrame
Transforms</span></a> that accept a <code class="docutils literal notranslate"><span class="pre">cols</span></code> parameter. Others include
<a class="reference internal" href="api.html#frankenfit.dataframe.ZScore" title="frankenfit.dataframe.ZScore"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ZScore</span></code></span></a>, <a class="reference internal" href="api.html#frankenfit.dataframe.Select" title="frankenfit.dataframe.Select"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Select</span></code></span></a>,
<a class="reference internal" href="api.html#frankenfit.dataframe.Drop" title="frankenfit.dataframe.Drop"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Drop</span></code></span></a>,
<a class="reference internal" href="api.html#frankenfit.dataframe.ImputeConstant" title="frankenfit.dataframe.ImputeConstant"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ImputeConstant</span></code></span></a>, and <a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref">many more</span></a>.
As a notational convenience, all of these Transforms allow <code class="docutils literal notranslate"><span class="pre">cols</span></code> to be given as a
single string, rather than a list of strings, in the case that the user wants the
Transform to apply to a single column.  Under the hood, this is converted to a length-1
list. So our previous example could also be written most succinctly as <code class="docutils literal notranslate"><span class="pre">Winsorize(0.05,</span> <span class="pre">&quot;price&quot;)</span></code>.</p>
<p>Furthermore, all of the Transforms in this family follow the convention that omitting
the <code class="docutils literal notranslate"><span class="pre">cols</span></code> argument indicates that the Transform should be applied to all columns in the
data, unless otherwise noted in the <a class="reference internal" href="api.html#api-reference"><span class="std std-ref">API reference</span></a>.</p>
<p>When implementing one’s own bespoke Transforms on DataFrames, it is possible to get this
same behavior by using the <a class="reference internal" href="api.html#frankenfit.columns_field" title="frankenfit.columns_field"><span class="xref myst py py-func"><code class="docutils literal notranslate"><span class="pre">columns_field</span></code></span></a> field-specifier;
see <a class="reference internal" href="implementing_transforms.html"><span class="doc">Implementing your own transforms</span></a>.</p>
</div>
<p>Once constructed, Transform instances carry their parameters as attributes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_2cols</span><span class="o">.</span><span class="n">cols</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;price&#39;, &#39;table&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_2cols</span><span class="o">.</span><span class="n">w_col</span> <span class="ow">is</span> <span class="kc">None</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>True
</pre></div>
</div>
</div>
</div>
<p>It is also possible to retrieve the names of a Transform’s parameters by calling the
<a class="reference internal" href="api.html#frankenfit.Transform.params" title="frankenfit.Transform.params"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">params()</span></code></span></a> method:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_2cols</span><span class="o">.</span><span class="n">params</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;tag&#39;, &#39;cols&#39;, &#39;w_col&#39;]
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">repr</span></code> of a Transform instance additionally shows the values of its parameters:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">display</span><span class="p">(</span>
    <span class="n">dmn_2cols</span><span class="p">,</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DeMean(tag=&#39;3&#39;, cols=[&#39;price&#39;, &#39;table&#39;], w_col=None)
</pre></div>
</div>
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Winsorize(tag=&#39;2&#39;, limit=0.01, cols=[&#39;price&#39;])
</pre></div>
</div>
</div>
</div>
<section id="tags">
<span id="transform-tags"></span><h4>Tags<a class="headerlink" href="#tags" title="Permalink to this headline">#</a></h4>
<p>The observant reader doubtlessly noticed the presence of a parameter named <code class="docutils literal notranslate"><span class="pre">&quot;tag&quot;</span></code> in
the examples above. This is a special, implicit parameter common to all Transforms. For
now we need only note its existence, and that it automatically receives a value, which
may be overridden by the <code class="docutils literal notranslate"><span class="pre">tag</span></code> keyword-only argument available to all Transforms, e.g.:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">win_price</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;winsorize_price&quot;</span><span class="p">)</span>
<span class="n">win_price</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Winsorize(tag=&#39;winsorize_price&#39;, limit=0.01, cols=[&#39;price&#39;])
</pre></div>
</div>
</div>
</div>
<p>Every Transform has a <code class="docutils literal notranslate"><span class="pre">name</span></code> attribute that incorporates its class name and <code class="docutils literal notranslate"><span class="pre">tag</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">win_price</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;Winsorize#winsorize_price&#39;
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dmn_2cols</span><span class="o">.</span><span class="n">name</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&#39;DeMean#3&#39;
</pre></div>
</div>
</div>
</div>
<p>This will come in handy later when we wish to refer to specific Transforms embedded in
larger pipelines, as described in <a class="reference internal" href="#tagging-selecting-transforms"><span class="std std-ref">Tagging and selecting
Transforms</span></a>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>While <code class="docutils literal notranslate"><span class="pre">tag</span></code> is a parameter, whose value may optionally be supplied when creating a
Transform, <code class="docutils literal notranslate"><span class="pre">name</span></code> is <em>not</em> a parameter, and cannot be set directly. It’s just a
read-only attribute whose value is automatically derived from the Transform’s class name
and <code class="docutils literal notranslate"><span class="pre">tag</span></code>.</p>
</div>
</section>
</section>
<section id="abstract-descriptions-and-immutability">
<h3>Abstract descriptions and immutability<a class="headerlink" href="#abstract-descriptions-and-immutability" title="Permalink to this headline">#</a></h3>
<p>Transform instances like <code class="docutils literal notranslate"><span class="pre">dmn</span></code> are best thought of as light-weight, abstract, immutable
descriptions of what to do to some as-yet unspecified data; they store no data or state
in and of themselves. They are essentially factories for producing
<a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a> instances by feeding data to their
<a class="reference internal" href="api.html#frankenfit.Transform.fit" title="frankenfit.Transform.fit"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></span></a> methods, and it’s those <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instances
which hold the (possibly heavyweight) state of the now-fit Transform, and are actually
capable of transforming data through their <a class="reference internal" href="api.html#frankenfit.FitTransform.apply" title="frankenfit.FitTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a>
methods.</p>
<p>Instances of <code class="docutils literal notranslate"><span class="pre">Transform</span></code> and <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> are both immutable and re-usable:</p>
<ul class="simple">
<li><p>A <code class="docutils literal notranslate"><span class="pre">Transform</span></code> instance is an immutable description of a transformation, with fixed
parameter values provided at the time of instantiation (although the use of
hyperparameters allows deferring the resolution of some or all parameter values until
the moment that <code class="docutils literal notranslate"><span class="pre">fit()</span></code> is called; see <a class="reference internal" href="hyperparams.html"><span class="doc">Hyperparameters</span></a>). It is re-usable in the
sense that a single <code class="docutils literal notranslate"><span class="pre">Transform</span></code> instance may be <code class="docutils literal notranslate"><span class="pre">fit()</span></code> on many different datasets,
each time returning a new instance of <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code>, never modifying its parameters
or the fitting data in the process.</p></li>
<li><p>A <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instance has some state which, once constructed by <code class="docutils literal notranslate"><span class="pre">Transform.fit()</span></code>,
is fixed and immutable. The instance may be re-used by calling <code class="docutils literal notranslate"><span class="pre">apply()</span></code> on many
different datasets. The <code class="docutils literal notranslate"><span class="pre">apply()</span></code> method never modifies the state nor the data that it
is given; it always returns a copy of the data in which the fit transformation has
been applied.</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It’s worth noting that nothing formally prevents a rogue <code class="docutils literal notranslate"><span class="pre">Transform</span></code> implementation from
modifying the fitting data or apply data. This is Python, after all. Immutability is
merely a convention to be followed when implementing a new <code class="docutils literal notranslate"><span class="pre">Transform</span></code>.</p>
<p>Furthermore, once the user has an instance of <code class="docutils literal notranslate"><span class="pre">Transform</span></code> or <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> in hand,
nothing truly prevents him from modifying its parameters or state. This should be
avoided except for a few extraordinary circumstances (e.g. making a modified copy of a
<code class="docutils literal notranslate"><span class="pre">Transform</span></code> whose type is not known at runtime), and in any case, the Pipeline
<a class="reference internal" href="#call-chain-api"><span class="std std-ref">call-chain API</span></a>, which is preferred over direct instantiation of
<code class="docutils literal notranslate"><span class="pre">Transform</span></code> objects, makes it inconvenient to do so.</p>
</div>
</section>
<section id="stateless-transforms">
<span id="id1"></span><h3>Stateless transforms<a class="headerlink" href="#stateless-transforms" title="Permalink to this headline">#</a></h3>
<p>A number of <a class="reference internal" href="api.html#frankenfit.Transform" title="frankenfit.Transform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Transforms</span></code></span></a> don’t actually have any state to fit;
Frankenfit calls these <a class="reference internal" href="api.html#frankenfit.StatelessTransform" title="frankenfit.StatelessTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">StatelessTransforms</span></code></span></a>. For these
Transforms, the <a class="reference internal" href="api.html#frankenfit.Transform.fit" title="frankenfit.Transform.fit"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">fit()</span></code></span></a> method is essentially a null
operation, and by convention the <a class="reference internal" href="api.html#frankenfit.FitTransform.state" title="frankenfit.FitTransform.state"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">state()</span></code></span></a> of the
resulting <a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a> is <code class="docutils literal notranslate"><span class="pre">None</span></code>. All of the action is in
<a class="reference internal" href="api.html#frankenfit.FitTransform.apply" title="frankenfit.FitTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a>.</p>
<p>For example, suppose we just want to log-transform some column like <code class="docutils literal notranslate"><span class="pre">price</span></code>; that is,
replace each value <span class="math notranslate nohighlight">\(x\)</span> with <span class="math notranslate nohighlight">\(\log(1+x)\)</span>. (The <span class="math notranslate nohighlight">\(1\)</span> is there to ensure that we don’t try
to compute <span class="math notranslate nohighlight">\(\log(0)\)</span>.) This is an operation that always gives the same result regardless
of what might be observed on any fitting data, hence stateless. We could of course
accomplish this directly with numpy and pandas:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">[[</span><span class="s2">&quot;price&quot;</span><span class="p">]])</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>2</th>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>3</th>
      <td>5.793014</td>
    </tr>
    <tr>
      <th>4</th>
      <td>5.814131</td>
    </tr>
    <tr>
      <th>5</th>
      <td>5.817111</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>But as we’ll see in the next section, it is often useful to be able to represent such
stateless data manipulations as Frankenfit <code class="docutils literal notranslate"><span class="pre">Transforms</span></code>, so that we can compose them
easily with other (possibly stateful) Transforms in our data pipelines, and generally
work with a common API for invoking all of our data manipulations.</p>
<p>The Frankenfit library provides a few workhorse <code class="docutils literal notranslate"><span class="pre">StatelessTransforms</span></code> that can be used
to wrap simple stateless operations like <code class="docutils literal notranslate"><span class="pre">np.log1p</span></code> above:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#frankenfit.dataframe.Pipe" title="frankenfit.dataframe.Pipe"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipe</span></code></span></a> lets us easily “pipe” (the specified
columns of) a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code> through an arbitrary function, as long as it accepts and
returns a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>:</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#frankenfit.universal.StatelessLambda" title="frankenfit.universal.StatelessLambda"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">StatelessLambda</span></code></span></a> is even more
generic. It passes the apply-time data (which may or may not be a <code class="docutils literal notranslate"><span class="pre">DataFrame</span></code>)
directly to a user-supplied function, returning the result.</p></li>
</ul>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price_lambda</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">universal</span><span class="o">.</span><span class="n">StatelessLambda</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">price</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]))</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The reader no doubt noticed that
<a class="reference internal" href="api.html#frankenfit.universal.StatelessLambda" title="frankenfit.universal.StatelessLambda"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">StatelessLambda</span></code></span></a> is kept under
<a class="reference internal" href="api.html#universal-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.universal</span></code></span></a>, rather than under
<a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code></span></a> like the other Transforms introduced so far. The
distinction is that <code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code> is for Transforms that operate on DataFrames,
while <code class="docutils literal notranslate"><span class="pre">frankenfit.universal</span></code> is for Transforms that make no assumption about the type of
the data.</p>
</div>
<p>To illustrate, <code class="docutils literal notranslate"><span class="pre">log_price</span></code> can be fit (always with <code class="docutils literal notranslate"><span class="pre">None</span></code> state) and applied like any
other Transform:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price_fit</span> <span class="o">=</span> <span class="n">log_price</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span><span class="n">log_price_fit</span><span class="o">.</span><span class="n">state</span><span class="p">())</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>None
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.23</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>5.793014</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>5.814131</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>5.817111</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Because <code class="docutils literal notranslate"><span class="pre">fit()</span></code> is a null operation, the fitting data argument is optional:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price</span><span class="o">.</span><span class="n">fit</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.23</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>5.793014</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>5.814131</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>5.817111</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>In fact, as a convenience, the <code class="docutils literal notranslate"><span class="pre">fit()</span></code> call can be skipped entirely:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">log_price</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">diamonds_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>5.789960</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.23</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>5.793014</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>5.814131</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>5.817111</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>All <code class="docutils literal notranslate"><span class="pre">StatlessTransforms</span></code> inherit an <a class="reference internal" href="api.html#frankenfit.StatelessTransform.apply" title="frankenfit.StatelessTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a>
method, which is syntactic sugar for <code class="docutils literal notranslate"><span class="pre">.fit(...).apply(...)</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>It’s important to remember that <em>stateful</em> Transforms like
<a class="reference internal" href="api.html#frankenfit.dataframe.DeMean" title="frankenfit.dataframe.DeMean"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DeMean</span></code></span></a> and
<a class="reference internal" href="api.html#frankenfit.dataframe.Winsorize" title="frankenfit.dataframe.Winsorize"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Winsorize</span></code></span></a> have no <code class="docutils literal notranslate"><span class="pre">apply()</span></code> method! They must
first be <code class="docutils literal notranslate"><span class="pre">fit()</span></code>, which returns a <a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a> instance,
and it’s the <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> that has <a class="reference internal" href="api.html#frankenfit.FitTransform.apply" title="frankenfit.FitTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a>.
Stateless Transforms can be fit and applied in the same manner, and
<a class="reference internal" href="api.html#frankenfit.StatelessTransform.apply" title="frankenfit.StatelessTransform.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">StatelessTransform.apply()</span></code></span></a> is merely a convenience.</p>
<p>Furthermore, the signature of <code class="docutils literal notranslate"><span class="pre">StatelessTransform.apply()</span></code> is a little different than
that of <code class="docutils literal notranslate"><span class="pre">FitTransform.apply()</span></code>, since it allows the specification of hyperparameter
bindings, which can only be given at fit-time.</p>
</div>
</section>
</section>
<section id="pipelines">
<h2>Pipelines<a class="headerlink" href="#pipelines" title="Permalink to this headline">#</a></h2>
<section id="composing-transforms">
<h3>Composing transforms<a class="headerlink" href="#composing-transforms" title="Permalink to this headline">#</a></h3>
<p>When modeling or analyzing some dataset, one usually wishes to <strong>compose</strong> many
Transforms. For example, consider the dataset of diamond prices and covariates:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">diamonds_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>0.23</td>
      <td>61.5</td>
      <td>55.0</td>
      <td>326</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.21</td>
      <td>59.8</td>
      <td>61.0</td>
      <td>326</td>
    </tr>
    <tr>
      <th>3</th>
      <td>0.23</td>
      <td>56.9</td>
      <td>65.0</td>
      <td>327</td>
    </tr>
    <tr>
      <th>4</th>
      <td>0.29</td>
      <td>62.4</td>
      <td>58.0</td>
      <td>334</td>
    </tr>
    <tr>
      <th>5</th>
      <td>0.31</td>
      <td>63.3</td>
      <td>58.0</td>
      <td>335</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>Suppose we want to build a model that predicts diamond prices as a function of their
weight (<code class="docutils literal notranslate"><span class="pre">carat</span></code>), pavilion <code class="docutils literal notranslate"><span class="pre">depth</span></code> (how “tall” the diamond is), and <code class="docutils literal notranslate"><span class="pre">table</span></code> diameter
(how wide the diamond’s uppermost facet is; see <a class="reference external" href="https://en.wikipedia.org/wiki/Diamond_cut#/media/File:Diamond_facets.svg">this
figure</a> on
wikipedia).</p>
<p>To do so, we can imagine fitting a simple linear regression model on these variables.
But first we note that these variables have very different ranges and scales from each
other, as well as outliers:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Recall that train_df is a random sample of half the observations in diamonds_df</span>
<span class="n">train_df</span><span class="o">.</span><span class="n">hist</span><span class="p">()</span>
<span class="n">train_df</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>count</th>
      <td>26970.000000</td>
      <td>26970.000000</td>
      <td>26970.000000</td>
      <td>26970.000000</td>
    </tr>
    <tr>
      <th>mean</th>
      <td>0.798533</td>
      <td>61.753700</td>
      <td>57.457683</td>
      <td>3934.948906</td>
    </tr>
    <tr>
      <th>std</th>
      <td>0.473374</td>
      <td>1.437325</td>
      <td>2.243235</td>
      <td>3982.199730</td>
    </tr>
    <tr>
      <th>min</th>
      <td>0.200000</td>
      <td>43.000000</td>
      <td>44.000000</td>
      <td>327.000000</td>
    </tr>
    <tr>
      <th>25%</th>
      <td>0.400000</td>
      <td>61.100000</td>
      <td>56.000000</td>
      <td>956.000000</td>
    </tr>
    <tr>
      <th>50%</th>
      <td>0.700000</td>
      <td>61.800000</td>
      <td>57.000000</td>
      <td>2398.000000</td>
    </tr>
    <tr>
      <th>75%</th>
      <td>1.050000</td>
      <td>62.500000</td>
      <td>59.000000</td>
      <td>5346.000000</td>
    </tr>
    <tr>
      <th>max</th>
      <td>4.130000</td>
      <td>79.000000</td>
      <td>95.000000</td>
      <td>18823.000000</td>
    </tr>
  </tbody>
</table>
</div></div><img alt="_images/transforms_and_pipelines_51_1.png" src="_images/transforms_and_pipelines_51_1.png" />
</div>
</div>
<p>Therefore in practice we’ll want to apply several feature-cleaning transformations to
the data before fitting a regression model. Specifically, let’s suppose we want to:</p>
<ol class="simple">
<li><p>Winsorize all four variables to trim outliers.</p></li>
<li><p>Log-transform the <code class="docutils literal notranslate"><span class="pre">carat</span></code> and <code class="docutils literal notranslate"><span class="pre">price</span></code> variables to make them more symmetric.</p></li>
<li><p>Z-score the three predictor variables to put them on the same scale with zero means.
(It’s important to do this after the previous steps, so that the means and standard
deviations used for the z-scores are not distorted by outliers.)</p></li>
<li><p>Fit a linear regression of <code class="docutils literal notranslate"><span class="pre">price</span></code> predicted by <code class="docutils literal notranslate"><span class="pre">carat</span></code>, <code class="docutils literal notranslate"><span class="pre">table</span></code>, and <code class="docutils literal notranslate"><span class="pre">depth</span></code>.</p></li>
<li><p>Finally, because we log-transformed <code class="docutils literal notranslate"><span class="pre">price</span></code>, exponentiate the predictions of the
regression model to put them back in the original units.</p></li>
</ol>
<p>The <a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code></span></a> module provides Transforms for all of these
operations (<a class="reference internal" href="api.html#frankenfit.dataframe.Winsorize" title="frankenfit.dataframe.Winsorize"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Winsorize</span></code></span></a>,
<a class="reference internal" href="api.html#frankenfit.dataframe.Pipe" title="frankenfit.dataframe.Pipe"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipe</span></code></span></a> <a class="reference internal" href="api.html#frankenfit.dataframe.ZScore" title="frankenfit.dataframe.ZScore"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ZScore</span></code></span></a>,
<a class="reference internal" href="api.html#frankenfit.dataframe.SKLearn" title="frankenfit.dataframe.SKLearn"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">SKLearn</span></code></span></a>), and naively we might manually combine them
to implement our end-to-end model. For example, we could instantiate our transforms like
so:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>

<span class="c1"># 1. Winsorize all four variables</span>
<span class="n">winsorize</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="c1"># 2. Log-transform carat and price</span>
<span class="n">log_price_carat</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;carat&quot;</span><span class="p">])</span>
<span class="c1"># 3. Z-score the three predictor variables</span>
<span class="n">z_score</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">ZScore</span><span class="p">([</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">])</span>
<span class="c1"># 4. Linear regression</span>
<span class="n">regress</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">SKLearn</span><span class="p">(</span>
    <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
    <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
    <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">,</span>
    <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>
    <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>  <span class="c1"># additional arguments for LinearRegression</span>
<span class="p">)</span>
<span class="c1"># 5. Exponentiate the predictions back to original units</span>
<span class="n">exp_price_hat</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>And then, whenever we want to fit our model on some fitting data, we go through a
procedure like that below, where each Transform is fit on the result of fitting and
applying the previous transform to the data:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># start with train_df as the input data</span>
<span class="n">winsorize_fit</span> <span class="o">=</span> <span class="n">winsorize</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">winsorize_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>

<span class="c1"># remember that Pipe is stateless, so we could skip the explicit call to fit(), but</span>
<span class="c1"># we&#39;ll use it here for symmetry with the other Transforms</span>
<span class="n">log_price_carat_fit</span> <span class="o">=</span> <span class="n">log_price_carat</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">log_price_carat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">z_score_fit</span> <span class="o">=</span> <span class="n">z_score</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">z_score_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">regress_fit</span> <span class="o">=</span> <span class="n">regress</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">regress_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">exp_price_hat_fit</span> <span class="o">=</span> <span class="n">exp_price_hat</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">exp_price_hat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>23038</th>
      <td>-1.155816</td>
      <td>-1.926416</td>
      <td>0.822812</td>
      <td>6.448889</td>
      <td>824.951175</td>
    </tr>
    <tr>
      <th>21478</th>
      <td>1.035128</td>
      <td>-2.097934</td>
      <td>0.822812</td>
      <td>9.166911</td>
      <td>6734.106885</td>
    </tr>
    <tr>
      <th>46890</th>
      <td>-0.720118</td>
      <td>0.303313</td>
      <td>-1.711384</td>
      <td>7.503841</td>
      <td>1273.600651</td>
    </tr>
    <tr>
      <th>10579</th>
      <td>1.094091</td>
      <td>0.303313</td>
      <td>-0.190866</td>
      <td>8.480529</td>
      <td>6841.459534</td>
    </tr>
    <tr>
      <th>45735</th>
      <td>-0.574508</td>
      <td>-0.640034</td>
      <td>-0.697706</td>
      <td>7.438384</td>
      <td>1455.919174</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>At the end of this process, we have a bunch of <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instances <code class="docutils literal notranslate"><span class="pre">winsorize_fit</span></code>,
<code class="docutils literal notranslate"><span class="pre">log_price_cara_fit</span></code>, <code class="docutils literal notranslate"><span class="pre">z_score_fit</span></code>, <code class="docutils literal notranslate"><span class="pre">regress_fit</span></code>, <code class="docutils literal notranslate"><span class="pre">exp_price_hat_fit</span></code>, as well as the
DataFrame <code class="docutils literal notranslate"><span class="pre">df</span></code>, which contains the results of applying our whole model to its own
fitting data.</p>
<p>Incidentally, we can see that the model does a reasonable job of predicting its own
fitting data, with a high correlation between <code class="docutils literal notranslate"><span class="pre">price_hat_dollars</span></code> and the original,
un-transformed <code class="docutils literal notranslate"><span class="pre">price</span></code>, though there is clearly some non-random structure to the errors:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eval_df</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">train_df</span><span class="p">[[</span><span class="s2">&quot;price&quot;</span><span class="p">]]</span>
    <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">price_hat</span><span class="o">=</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;price_hat&quot;</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">eval_df</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="n">eval_df</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="n">eval_df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price</th>
      <td>1.000000</td>
      <td>0.926595</td>
    </tr>
    <tr>
      <th>price_hat</th>
      <td>0.926595</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div></div><img alt="_images/transforms_and_pipelines_57_1.png" src="_images/transforms_and_pipelines_57_1.png" />
<img alt="_images/transforms_and_pipelines_57_2.png" src="_images/transforms_and_pipelines_57_2.png" />
</div>
</div>
<p>Even more incidentally, the <code class="docutils literal notranslate"><span class="pre">state()</span></code> of <code class="docutils literal notranslate"><span class="pre">regress_fit</span></code> is just a (fit) scikit-learn
<a class="reference external" href="https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html"><code class="docutils literal notranslate"><span class="pre">LinearRegression</span></code></a> object, so if we are interested in the betas learned for the predictors, we can access
them in the usual way. Unsurprisingly, it seems that <code class="docutils literal notranslate"><span class="pre">carat</span></code> is the most important by
far for predicting <code class="docutils literal notranslate"><span class="pre">price</span></code> (so much so that if we were doing this for real, we might
consider dropping the other predictors altogether):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">regress_fit</span><span class="o">.</span><span class="n">state</span><span class="p">()</span><span class="o">.</span><span class="n">coef_</span><span class="p">,</span> <span class="n">regress_fit</span><span class="o">.</span><span class="n">state</span><span class="p">()</span><span class="o">.</span><span class="n">intercept_</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([ 0.95536379, -0.03466946, -0.03150901]), 7.788587529099264)
</pre></div>
</div>
</div>
</div>
<p>To predict the prices of previously unseen diamonds, we must go through a similar
process of applying each <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> in turn to some new dataset with the same
schema:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># recall that test_df is the other half of diamonds_df</span>
<span class="c1"># we use &quot;oos&quot; as an abbreviation of &quot;out-of-sample&quot;</span>
<span class="n">df_oos</span> <span class="o">=</span> <span class="n">winsorize_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
<span class="n">df_oos</span> <span class="o">=</span> <span class="n">log_price_carat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df_oos</span><span class="p">)</span>
<span class="n">df_oos</span> <span class="o">=</span> <span class="n">z_score_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df_oos</span><span class="p">)</span>
<span class="n">df_oos</span> <span class="o">=</span> <span class="n">regress_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df_oos</span><span class="p">)</span>
<span class="n">df_oos</span> <span class="o">=</span> <span class="n">exp_price_hat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df_oos</span><span class="p">)</span>

<span class="n">df_oos</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-1.255136</td>
      <td>-0.211240</td>
      <td>-1.204545</td>
      <td>6.300786</td>
      <td>762.484358</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.255136</td>
      <td>-1.669140</td>
      <td>1.836491</td>
      <td>6.300786</td>
      <td>718.386357</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-1.255136</td>
      <td>0.560590</td>
      <td>0.315973</td>
      <td>6.300786</td>
      <td>705.877597</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-1.221777</td>
      <td>1.332419</td>
      <td>0.315973</td>
      <td>6.300786</td>
      <td>711.235089</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-1.255136</td>
      <td>0.903625</td>
      <td>-0.190866</td>
      <td>6.300786</td>
      <td>710.674512</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>The virtue of using <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> objects like this is that our entire end-to-end model
of diamond prices, including feature cleaning and regression, was fit strictly on one
set of data (<code class="docutils literal notranslate"><span class="pre">train_df</span></code>) and is being applied strictly out-of-sample to new data
(<code class="docutils literal notranslate"><span class="pre">test_df</span></code>). The data in <code class="docutils literal notranslate"><span class="pre">test_df</span></code> is winsorized using the quantiles that were observed
in <code class="docutils literal notranslate"><span class="pre">train_df</span></code>, it’s z-scored using the means and standard deviations that were observed
in <code class="docutils literal notranslate"><span class="pre">train_df</span></code>, and predicted prices are generated using the regression betas that were
learned on <code class="docutils literal notranslate"><span class="pre">train_df</span></code>.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>There is, to invent some terminology, a clean separation between <strong>fit-time</strong> and
<strong>apply-time</strong>.</p>
</div>
<p>As expected, the out-of-sample predictions are not as correlated with observed <code class="docutils literal notranslate"><span class="pre">price</span></code>
as the in-sample predictions, although the degradation is miniscule, perhaps suggesting
that our training set was not very biased:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eval_oos_df</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">test_df</span><span class="p">[[</span><span class="s2">&quot;price&quot;</span><span class="p">]]</span>
    <span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">price_hat</span><span class="o">=</span><span class="n">df_oos</span><span class="p">[</span><span class="s2">&quot;price_hat&quot;</span><span class="p">])</span>
<span class="p">)</span>
<span class="n">eval_oos_df</span><span class="o">.</span><span class="n">corr</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price</th>
      <td>1.000000</td>
      <td>0.925196</td>
    </tr>
    <tr>
      <th>price_hat</th>
      <td>0.925196</td>
      <td>1.000000</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
<section id="pipeline-transforms">
<h3>Pipeline transforms<a class="headerlink" href="#pipeline-transforms" title="Permalink to this headline">#</a></h3>
<p>Now, this is generally <strong>not</strong> how one should use Frankenfit to implement data modeling
pipelines. The example above serves merely to introduce the basic principles from the
ground up, so to speak. Rather than manually chaining Transforms together in a laborious
and error-prone way as we saw above, we should use a special Transform, called
<a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a> (and its subclasses), which <em>contains other
Transforms.</em> The <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> Transform takes a single parameter, <code class="docutils literal notranslate"><span class="pre">transforms</span></code>, which is a
list of Transforms to be composed together sequentially as we did manually above.</p>
<p>Our diamond price-modeling pipeline can be rewritten as an actual <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> like so:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span>
    <span class="n">transforms</span><span class="o">=</span><span class="p">[</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;carat&quot;</span><span class="p">]),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">ZScore</span><span class="p">([</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">]),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">SKLearn</span><span class="p">(</span>
            <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
            <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
            <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">,</span>
            <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>
            <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="p">),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>Now when we fit this <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> object <code class="docutils literal notranslate"><span class="pre">price_model</span></code> (which is just a <code class="docutils literal notranslate"><span class="pre">Transform</span></code> like
any other), it will handle the logic of feeding each constituent Transform’s output into
the next Transform in the sequence. The state of the <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> that results from fitting a
<code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> is the list of the states of all of the constituent <code class="docutils literal notranslate"><span class="pre">FitTransforms</span></code>; applying it applies each constituent <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> in sequence.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-1.255136</td>
      <td>-0.211240</td>
      <td>-1.204545</td>
      <td>6.300786</td>
      <td>762.484358</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.255136</td>
      <td>-1.669140</td>
      <td>1.836491</td>
      <td>6.300786</td>
      <td>718.386357</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-1.255136</td>
      <td>0.560590</td>
      <td>0.315973</td>
      <td>6.300786</td>
      <td>705.877597</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-1.221777</td>
      <td>1.332419</td>
      <td>0.315973</td>
      <td>6.300786</td>
      <td>711.235089</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-1.255136</td>
      <td>0.903625</td>
      <td>-0.190866</td>
      <td>6.300786</td>
      <td>710.674512</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>As before, every stateful constituent Transform (<code class="docutils literal notranslate"><span class="pre">Winsorize</span></code>, <code class="docutils literal notranslate"><span class="pre">ZScore</span></code>, <code class="docutils literal notranslate"><span class="pre">SKLearn</span></code>) is
applied strictly <strong>out-of-sample</strong> using whatever state it learned on the fitting data.
Wrapping up a composition of Transforms as a single Transform like this is quite
powerful because it allows one easily to re-use the whole end-to-end model on multiple
datasets, to embed it within other Pipelines, and so on. For example, since
<code class="docutils literal notranslate"><span class="pre">price_model</span></code> is just a <code class="docutils literal notranslate"><span class="pre">Transform</span></code>, we could compose it with a
<a class="reference internal" href="api.html#frankenfit.dataframe.Copy" title="frankenfit.dataframe.Copy"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Copy</span></code></span></a> Transform that preserves the original <code class="docutils literal notranslate"><span class="pre">price</span></code> column
before all of the winsorizing and standardizing, and a
<a class="reference internal" href="api.html#frankenfit.dataframe.Correlation" title="frankenfit.dataframe.Correlation"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Correlation</span></code></span></a> Transform that computes the
correlation between (standardized) <code class="docutils literal notranslate"><span class="pre">price_orig</span></code> and <code class="docutils literal notranslate"><span class="pre">price_hat</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model_corr</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span>
    <span class="n">transforms</span><span class="o">=</span><span class="p">[</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Copy</span><span class="p">(</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;price_orig&quot;</span><span class="p">),</span>
        <span class="n">price_model</span><span class="p">,</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Correlation</span><span class="p">([</span><span class="s2">&quot;price_orig&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;price_hat&quot;</span><span class="p">])</span>
    <span class="p">]</span>
<span class="p">)</span>

<span class="n">price_model_corr_fit</span> <span class="o">=</span> <span class="n">price_model_corr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">price_model_corr_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>  <span class="c1"># correlation on its own training data</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_orig</th>
      <td>0.929112</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model_corr_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>  <span class="c1"># correlation on test data</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_orig</th>
      <td>0.927241</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
</section>
<section id="the-call-chain-api">
<span id="call-chain-api"></span><h3>The call-chain API<a class="headerlink" href="#the-call-chain-api" title="Permalink to this headline">#</a></h3>
<p>In the previous section we created the <code class="docutils literal notranslate"><span class="pre">price_model</span></code> <a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a>
by directly supplying the <code class="docutils literal notranslate"><span class="pre">transforms</span></code> parameter as a list of <code class="docutils literal notranslate"><span class="pre">Transform</span></code> objects:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">(</span>
    <span class="n">transforms</span><span class="o">=</span><span class="p">[</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;carat&quot;</span><span class="p">]),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">ZScore</span><span class="p">([</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">]),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">SKLearn</span><span class="p">(</span>
            <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
            <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
            <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">,</span>
            <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>
            <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
        <span class="p">),</span>
        <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">),</span>
    <span class="p">]</span>
<span class="p">)</span>
</pre></div>
</div>
<p>While useful for illustrating how Pipelines work internally, this is generally
<em>not</em> the preferred way to write data-modeling pipelines with Frankenfit. Instead we
use what we call the <strong>call-chain API</strong>, so named because it involves making a “chain”
of method calls on Pipeline objects to build up the sequence of Transforms
incrementally. This style of writing Pipelines is more concise and readable (effectively
a domain-specific language), taking inspiration from Pandas’ own <a class="reference external" href="https://tomaugspurger.github.io/posts/method-chaining/">similar style of
usage</a>.</p>
<p>Using the call-chain API, our <code class="docutils literal notranslate"><span class="pre">price_model</span></code> pipeline can be written more idiomatically
as follows:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;carat&quot;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">z_score</span><span class="p">([</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">sk_learn</span><span class="p">(</span>
        <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
        <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
        <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price&quot;</span><span class="p">,</span>
        <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>
        <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>One can see two main differences from the previous style of writing a Pipeline:</p>
<ol>
<li><p>Instead of constructing an instance of <a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a>, we begin by
constructing an instance of <a class="reference internal" href="api.html#frankenfit.DataFramePipeline" title="frankenfit.DataFramePipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code></span></a>.</p>
<p>This is because <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> is just a generic base class. It provides the core
functionality common to all pipelines, but no call-chain
methods.<a class="footnote-reference brackets" href="#footnote-if-fitting" id="id2">1</a> As noted earlier, Frankenfit’s library of built-in
Transforms is organized into submodules:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#universal-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankefit.universal</span></code></span></a> for generically useful Transforms that make
no assumptions about the type or shape of the data.</p></li>
<li><p><a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code></span></a> for Transforms that operate on <code class="docutils literal notranslate"><span class="pre">DataFrames</span></code>.</p></li>
</ul>
<p>These also provide subclasses of <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>, available to users directly under the
<code class="docutils literal notranslate"><span class="pre">frankenfit</span></code> package namespace:</p>
<ul class="simple">
<li><p><a class="reference internal" href="api.html#frankenfit.UniversalPipeline" title="frankenfit.UniversalPipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ff.UniversalPipeline</span></code></span></a> defines call-chain methods
for all of the Transforms in <code class="docutils literal notranslate"><span class="pre">frankenfit.universal</span></code>.</p></li>
<li><p><a class="reference internal" href="api.html#frankenfit.DataFramePipeline" title="frankenfit.DataFramePipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ff.DataFramePipeline</span></code></span></a> defines call-chain methods for all
of the Transforms in <code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code>, <em>in addition to</em> those in
<code class="docutils literal notranslate"><span class="pre">frankenfit.universal</span></code>. (<code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code> is in fact a subclass of
<code class="docutils literal notranslate"><span class="pre">UniversalPipeline</span></code>.)</p></li>
</ul>
<p>Thus when writing our pipelines, we’ll almost always be using <code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code> (or
<code class="docutils literal notranslate"><span class="pre">UniversalPipeline</span></code>) rather than <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>, in order to use the call-chain methods.</p>
</li>
<li><p>Rather than passing a list of <code class="docutils literal notranslate"><span class="pre">Transform</span></code> objects, we make a chain of method-calls;
the method names are the <a class="reference external" href="https://en.wikipedia.org/wiki/Snake_case">snake_case</a>
transliterations of the corresponding
<a class="reference external" href="https://en.wikipedia.org/wiki/Camel_case">CamelCase</a> <code class="docutils literal notranslate"><span class="pre">Tranform</span></code> class names.</p>
<p>We construct an initially empty pipeline with <code class="docutils literal notranslate"><span class="pre">DataFramePipeline()</span></code> and then proceed
to append Transforms to it with successive method calls. Each call passes its
arguments to the corresponding <code class="docutils literal notranslate"><span class="pre">Transform</span></code> class constructor and returns a new
pipeline with that <code class="docutils literal notranslate"><span class="pre">Transform</span></code> appended, ready for the next method call.</p>
</li>
</ol>
<p>It’s important to note that each method call returns a <em>new</em> <code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code>
instance with an additional <code class="docutils literal notranslate"><span class="pre">Transform</span></code> at the end of its <code class="docutils literal notranslate"><span class="pre">transforms</span></code> parameter. The
initial <code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code> object is never modified:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">empty_pipeline</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
<span class="n">empty_pipeline</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DataFramePipeline(tag=&#39;10&#39;, transforms=[])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pip</span> <span class="o">=</span> <span class="n">empty_pipeline</span><span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
<span class="n">pip</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DataFramePipeline(tag=&#39;11&#39;, transforms=[Winsorize(tag=&#39;6&#39;, limit=0.05, cols=&lt;ALL_COLS&gt;)])
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># empty_pipeline is still as it was</span>
<span class="n">empty_pipeline</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>DataFramePipeline(tag=&#39;10&#39;, transforms=[])
</pre></div>
</div>
</div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p>More details and nuances of the call-chain API, having to do with Transforms that group
and nest other Transforms (possibly sub-pipelines), are covered in <a class="reference internal" href="dataframes.html"><span class="doc">Working with DataFrames and DataFramePipelines</span></a> and
<a class="reference internal" href="branching_and_grouping.html"><span class="doc">Branching and grouping transforms</span></a></p>
</div>
</section>
<section id="fit-and-apply-in-one-go-pipeline-apply">
<h3>Fit-and-apply in one go: <code class="docutils literal notranslate"><span class="pre">Pipeline.apply()</span></code><a class="headerlink" href="#fit-and-apply-in-one-go-pipeline-apply" title="Permalink to this headline">#</a></h3>
<p>A common operation with a Pipeline is to fit it and apply it on the same dataset, as in:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>23038</th>
      <td>-1.155816</td>
      <td>-1.926416</td>
      <td>0.822812</td>
      <td>6.448889</td>
      <td>824.951175</td>
    </tr>
    <tr>
      <th>21478</th>
      <td>1.035128</td>
      <td>-2.097934</td>
      <td>0.822812</td>
      <td>9.166911</td>
      <td>6734.106885</td>
    </tr>
    <tr>
      <th>46890</th>
      <td>-0.720118</td>
      <td>0.303313</td>
      <td>-1.711384</td>
      <td>7.503841</td>
      <td>1273.600651</td>
    </tr>
    <tr>
      <th>10579</th>
      <td>1.094091</td>
      <td>0.303313</td>
      <td>-0.190866</td>
      <td>8.480529</td>
      <td>6841.459534</td>
    </tr>
    <tr>
      <th>45735</th>
      <td>-0.574508</td>
      <td>-0.640034</td>
      <td>-0.697706</td>
      <td>7.438384</td>
      <td>1455.919174</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p>However, as written above, this is inefficient. Recall that, under the hood,
<code class="docutils literal notranslate"><span class="pre">price_model.fit(train_df)</span></code> does something like this:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">winsorize_fit</span> <span class="o">=</span> <span class="n">winsorize</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">winsorize_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>

<span class="n">log_price_carat_fit</span> <span class="o">=</span> <span class="n">log_price_carat</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">log_price_carat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">z_score_fit</span> <span class="o">=</span> <span class="n">z_score</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">z_score_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">regress_fit</span> <span class="o">=</span> <span class="n">regress</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">regress_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<span class="n">exp_price_hat_fit</span> <span class="o">=</span> <span class="n">exp_price_hat</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
<span class="n">df</span> <span class="o">=</span> <span class="n">exp_price_hat_fit</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In order to fit the next <code class="docutils literal notranslate"><span class="pre">Transform</span></code> in the sequence, <code class="docutils literal notranslate"><span class="pre">Pipeline.fit()</span></code> needs the result
of applying the previous <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> to the fitting data. This means that by the time
it has fit all of the Transforms, it has, as a side-effect, already computed the result
of applying the whole Pipeline to its own fitting data. This is exactly what <code class="docutils literal notranslate"><span class="pre">df</span></code> is by
the end of our example above.</p>
<p>Thus when we call <code class="docutils literal notranslate"><span class="pre">apply()</span></code> on the Pipeline’s own fitting data as in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
</pre></div>
</div>
<p>…we are duplicating work. All of the constituent <code class="docutils literal notranslate"><span class="pre">FitTransforms</span></code> will be applied to
<code class="docutils literal notranslate"><span class="pre">train_df</span></code>, which is exactly what happened already at fit-time.</p>
<p>For this reason, unlike ordinary stateful Transforms, Pipelines come with an
<a class="reference internal" href="api.html#frankenfit.Pipeline.apply" title="frankenfit.Pipeline.apply"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply()</span></code></span></a> method (otherwise <code class="docutils literal notranslate"><span class="pre">apply()</span></code> is only available on
<code class="docutils literal notranslate"><span class="pre">StatelessTransforms</span></code> as discussed <a class="reference internal" href="#stateless-transforms"><span class="std std-ref">above</span></a>, or on the
<code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> object returned by <code class="docutils literal notranslate"><span class="pre">fit()</span></code>). Calling it on some data is equivalent
to fitting and then applying the Pipeline on the same data, but more efficient.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">assert</span> <span class="p">(</span>
    <span class="n">price_model</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
    <span class="o">.</span><span class="n">equals</span><span class="p">(</span>
        <span class="n">price_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>In general the only reason to call <code class="docutils literal notranslate"><span class="pre">Pipeline.fit()</span></code> is if one plans to apply the
resulting <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> to some out-of-sample data, as in:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># note the apply data is different than the fitting data</span>
<span class="n">price_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
</pre></div>
</div>
<p>The following table summarizes the distribution of <code class="docutils literal notranslate"><span class="pre">fit()</span></code> and <code class="docutils literal notranslate"><span class="pre">apply()</span></code> methods:</p>
<div class="table-wrapper colwidths-auto docutils container">
<table class="colwidths-auto docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">fit()</span></code></p></th>
<th class="head"><p><code class="docutils literal notranslate"><span class="pre">apply()</span></code></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#frankenfit.Transform" title="frankenfit.Transform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Transform</span></code></span></a></p></td>
<td><p>✔</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a></p></td>
<td><p></p></td>
<td><p>✔</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="api.html#frankenfit.StatelessTransform" title="frankenfit.StatelessTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">StatelessTransform</span></code></span></a></p></td>
<td><p>✔</p></td>
<td><p>✔</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a></p></td>
<td><p>✔</p></td>
<td><p>✔</p></td>
</tr>
</tbody>
</table>
</div>
</section>
<section id="visualizing-pipelines">
<span id="id3"></span><h3>Visualizing pipelines<a class="headerlink" href="#visualizing-pipelines" title="Permalink to this headline">#</a></h3>
<p>Because <code class="docutils literal notranslate"><span class="pre">price_model</span></code> is just a Transform, we can query its <code class="docutils literal notranslate"><span class="pre">params()</span></code> like any other
Transform, and access their values as attributes:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">params</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&#39;tag&#39;, &#39;transforms&#39;]
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">transforms</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[Winsorize(tag=&#39;5&#39;, limit=0.05, cols=&lt;ALL_COLS&gt;),
 Pipe(tag=&#39;6&#39;, apply_fun=&lt;ufunc &#39;log1p&#39;&gt;, cols=[&#39;price&#39;, &#39;carat&#39;]),
 ZScore(tag=&#39;3&#39;, cols=[&#39;carat&#39;, &#39;table&#39;, &#39;depth&#39;], w_col=None),
 SKLearn(tag=&#39;3&#39;, sklearn_class=&lt;class &#39;sklearn.linear_model._base.LinearRegression&#39;&gt;, x_cols=[&#39;carat&#39;, &#39;table&#39;, &#39;depth&#39;], response_col=HPFmtStr(name=&#39;price&#39;), hat_col=HPFmtStr(name=&#39;price_hat&#39;), class_params={&#39;fit_intercept&#39;: True}, w_col=&#39;&#39;),
 Pipe(tag=&#39;7&#39;, apply_fun=&lt;ufunc &#39;expm1&#39;&gt;, cols=[&#39;price_hat&#39;])]
</pre></div>
</div>
</div>
</div>
<p>However, for a complicated <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>, it can be difficult to figure out what it is
doing by looking at the raw <code class="docutils literal notranslate"><span class="pre">transforms</span></code> list. The
<a class="reference internal" href="api.html#frankenfit.Transform.visualize" title="frankenfit.Transform.visualize"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">visualize</span></code></span></a> method uses the <a class="reference external" href="https://pypi.org/project/graphviz/">GraphViz
library</a> to produce a visualization of the Pipeline
as an ordered sequence of Transforms:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">price_model</span><span class="o">.</span><span class="n">visualize</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_91_0.svg" src="_images/transforms_and_pipelines_91_0.svg" /></div>
</div>
<p>It’s worth noting that <code class="docutils literal notranslate"><span class="pre">visualize</span></code> is in fact a method available on all <code class="docutils literal notranslate"><span class="pre">Transform</span></code> objects, not just <code class="docutils literal notranslate"><span class="pre">Pipelines</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">Winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span><span class="o">.</span><span class="n">visualize</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_93_0.svg" src="_images/transforms_and_pipelines_93_0.svg" /></div>
</div>
<p>This becomes especially useful for certain complex Transforms that group or combine
other Transforms, such as those covered in <a class="reference internal" href="branching_and_grouping.html"><span class="doc">Branching and grouping transforms</span></a>.</p>
</section>
<section id="concatenating-pipelines">
<h3>Concatenating pipelines<a class="headerlink" href="#concatenating-pipelines" title="Permalink to this headline">#</a></h3>
<p>Once defined, Pipelines can be composed together in various ways. The simplest is
<strong>concatenation</strong>, whereby one Pipeline’s sequence of Transforms is followed immediately
by that of another.</p>
<p>For example, we could break our <code class="docutils literal notranslate"><span class="pre">price_model</span></code> Pipeline up into smaller parts. Along the
way we’ll introduce an additional step,
<a class="reference internal" href="api.html#frankenfit.dataframe.Copy" title="frankenfit.dataframe.Copy"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">copy(&quot;price&quot;,</span> <span class="pre">&quot;price_train&quot;)</span></code></span></a>, so that we can prepare
a training response column while preserving the original unmodified <code class="docutils literal notranslate"><span class="pre">price</span></code> column for
later evaluation of our predictions:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># we&#39;ll fit our regression on a winsorized and log-transformed *copy* of price</span>
<span class="n">prepare_training_response</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="s2">&quot;price_train&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="s2">&quot;price_train&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="s2">&quot;price_train&quot;</span><span class="p">)</span>
<span class="p">)</span>

<span class="n">prepare_features</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">])</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log1p</span><span class="p">,</span> <span class="s2">&quot;carat&quot;</span><span class="p">)</span>
    <span class="o">.</span><span class="n">z_score</span><span class="p">([</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">])</span>
<span class="p">)</span>

<span class="n">predict_price</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sk_learn</span><span class="p">(</span>
        <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
        <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
        <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price_train&quot;</span><span class="p">,</span>
        <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>  <span class="c1"># &lt;---</span>
        <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>We can concatenate these three smaller Pipelines into a complete model using
<a class="reference internal" href="api.html#frankenfit.Pipeline.then" title="frankenfit.Pipeline.then"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">then()</span></code></span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combined_model</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">prepare_training_response</span>
    <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">prepare_features</span><span class="p">)</span>
    <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">predict_price</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">combined_model</span><span class="o">.</span><span class="n">visualize</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_98_0.svg" src="_images/transforms_and_pipelines_98_0.svg" /></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_model</span> <span class="o">=</span> <span class="n">combined_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">fit_model</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>carat</th>
      <th>depth</th>
      <th>table</th>
      <th>price</th>
      <th>price_train</th>
      <th>price_hat</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>1</th>
      <td>-1.255136</td>
      <td>-0.211240</td>
      <td>-1.204545</td>
      <td>326</td>
      <td>6.300786</td>
      <td>762.484358</td>
    </tr>
    <tr>
      <th>2</th>
      <td>-1.255136</td>
      <td>-1.669140</td>
      <td>1.836491</td>
      <td>326</td>
      <td>6.300786</td>
      <td>718.386357</td>
    </tr>
    <tr>
      <th>4</th>
      <td>-1.255136</td>
      <td>0.560590</td>
      <td>0.315973</td>
      <td>334</td>
      <td>6.300786</td>
      <td>705.877597</td>
    </tr>
    <tr>
      <th>5</th>
      <td>-1.221777</td>
      <td>1.332419</td>
      <td>0.315973</td>
      <td>335</td>
      <td>6.300786</td>
      <td>711.235089</td>
    </tr>
    <tr>
      <th>6</th>
      <td>-1.255136</td>
      <td>0.903625</td>
      <td>-0.190866</td>
      <td>336</td>
      <td>6.300786</td>
      <td>710.674512</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">p1.then(p2)</span></code> does pretty much what you’d expect: a new <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> (of the same subclass
as <code class="docutils literal notranslate"><span class="pre">p1</span></code>, so in our case a <code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code>) is returned whose <code class="docutils literal notranslate"><span class="pre">transforms</span></code> parameter
is <code class="docutils literal notranslate"><span class="pre">p1.transforms</span> <span class="pre">+</span> <span class="pre">p2.transforms</span></code>.</p>
<p>As a bit of syntactic sugar, the <code class="docutils literal notranslate"><span class="pre">__add__</span></code> operator is overridden so that Pipelines can
also be concatenated using addition syntax:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combined_model</span> <span class="o">=</span> <span class="n">prepare_training_response</span> <span class="o">+</span> <span class="n">prepare_features</span> <span class="o">+</span> <span class="n">predict_price</span>
</pre></div>
</div>
</div>
</div>
<p>Concatenation enables greater re-usability of our pipelines. For example, a common setup
might be that we have several different predictive data models for some problem, and
separately, we have one or more ways of “scoring” their predictions. We can easily pick
a model, pick a scoring method, and combine them, as in:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">score_predictions</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span><span class="o">.</span><span class="n">correlation</span><span class="p">([</span><span class="s2">&quot;price_hat&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">])</span>

<span class="p">(</span><span class="n">combined_model</span> <span class="o">+</span> <span class="n">score_predictions</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>  <span class="c1"># in-sample score</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_hat</th>
      <td>0.926595</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<section id="other-uses-of-then">
<h4>Other uses of <code class="docutils literal notranslate"><span class="pre">then()</span></code><a class="headerlink" href="#other-uses-of-then" title="Permalink to this headline">#</a></h4>
<p>Concatenation via <code class="docutils literal notranslate"><span class="pre">then()</span></code> is also a good way of introducing a <code class="docutils literal notranslate"><span class="pre">Transform</span></code> that doesn’t
have a corresponding call-chain method (say because it’s a custom <code class="docutils literal notranslate"><span class="pre">Transform</span></code> subclass
of the user’s own devising; but see <a class="reference internal" href="implementing_transforms.html"><span class="doc">Implementing your own transforms</span></a> and in particular
<a class="reference internal" href="api.html#frankenfit.Pipeline.with_methods" title="frankenfit.Pipeline.with_methods"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">Pipeline.with_methods()</span></code></span></a> for other ways of
addressing this):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">...</span>
    <span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">MyGreatTransform</span><span class="p">(</span><span class="o">...</span><span class="p">))</span>
    <span class="o">...</span>
<span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">then()</span></code> can also be used to initiate a call-chain sequence if one is starting with a
bare <code class="docutils literal notranslate"><span class="pre">Transform</span></code> instance outside of a <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code>. Without any arguments, <code class="docutils literal notranslate"><span class="pre">then()</span></code>
returns a Pipeline containing <code class="docutils literal notranslate"><span class="pre">self</span></code>. For example</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># suppose we have a bare DeMean object from somewhere...</span>
<span class="n">de_mean</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">dataframe</span><span class="o">.</span><span class="n">DeMean</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">)</span>
<span class="c1"># we can start a DataFramePipeline by calling then()</span>
<span class="n">my_pipeline</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">de_mean</span>
    <span class="o">.</span><span class="n">then</span><span class="p">()</span>
    <span class="o">.</span><span class="n">winsorize</span><span class="p">(</span><span class="mf">0.05</span><span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">,</span> <span class="s2">&quot;bar&quot;</span><span class="p">)</span>
<span class="p">)</span>
<span class="n">my_pipeline</span><span class="o">.</span><span class="n">visualize</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_105_0.svg" src="_images/transforms_and_pipelines_105_0.svg" /></div>
</div>
<div class="admonition tip">
<p class="admonition-title">Tip</p>
<p>The <code class="docutils literal notranslate"><span class="pre">then()</span></code> method of Transforms defined in <a class="reference internal" href="api.html#universal-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.universal</span></code></span></a>
returns a <a class="reference internal" href="api.html#frankenfit.UniversalPipeline" title="frankenfit.UniversalPipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">UniversalPipeline</span></code></span></a>, while that of those
defined in <a class="reference internal" href="api.html#dataframe-api"><span class="std std-ref"><code class="docutils literal notranslate"><span class="pre">frankenfit.dataframe</span></code></span></a> returns a
<a class="reference internal" href="api.html#frankenfit.DataFramePipeline" title="frankenfit.DataFramePipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">DataFramePipeline</span></code></span></a>.</p>
</div>
</section>
</section>
<section id="including-fittransforms-in-a-pipeline">
<span id="including-fittransforms"></span><h3>Including <code class="docutils literal notranslate"><span class="pre">FitTransforms</span></code> in a pipeline<a class="headerlink" href="#including-fittransforms-in-a-pipeline" title="Permalink to this headline">#</a></h3>
<p>Pipelines may only contain <a class="reference internal" href="api.html#frankenfit.Transform" title="frankenfit.Transform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Transforms</span></code></span></a>, but often we might wish
to include an already-fit <a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a> in a Pipeline,
potentially alongside some (unfit) <code class="docutils literal notranslate"><span class="pre">Transforms</span></code>.  This is possible using a built-in
utility Transform called <a class="reference internal" href="api.html#frankenfit.core.ApplyFitTransform" title="frankenfit.core.ApplyFitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code></span></a>
(call-chain method <a class="reference internal" href="api.html#frankenfit.Pipeline.apply_fit_transform" title="frankenfit.Pipeline.apply_fit_transform"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply_fit_transform()</span></code></span></a>),
whose purpose is to wrap an already-fit <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instance as a stateless
Transform. At fit-time, <code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code> does nothing; at apply-time, it applies the
wrapped <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instance. This allows one to embed <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> objects
wherever <code class="docutils literal notranslate"><span class="pre">Transform</span></code> is ordinarily required, for example in a
<a class="reference internal" href="api.html#frankenfit.Pipeline" title="frankenfit.Pipeline"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Pipeline</span></code></span></a>.</p>
<p>This is particularly useful in situations where we’ve already fit some predictive
pipeline, and now we want to layer some additional transformations onto its input or
output. Because those transformations may be stateful themselves, we can even create
“heterogeneously fit” Pipelines, wherein different parts of the Pipeline have been fit
on different datasets.</p>
<p>For example, continuing with our <code class="docutils literal notranslate"><span class="pre">fit_model</span></code> (a <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> instance) from above, now
that we’ve fit that model on <code class="docutils literal notranslate"><span class="pre">train_df</span></code>, we might be interested to know how it performs
on the subset of <code class="docutils literal notranslate"><span class="pre">test_df</span></code> with just the largest diamonds, say those weighting at least
one carat. We can use the <a class="reference internal" href="api.html#frankenfit.dataframe.Filter" title="frankenfit.dataframe.Filter"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">Filter</span></code></span></a> Transform (call-chain
method <a class="reference internal" href="api.html#frankenfit.dataframe.DataFrameCallChain.filter" title="frankenfit.dataframe.DataFrameCallChain.filter"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">filter()</span></code></span></a>) to select the rows
in question, and send them to our <code class="docutils literal notranslate"><span class="pre">fit_model</span></code> with <code class="docutils literal notranslate"><span class="pre">apply_fit_transform()</span></code>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
    <span class="o">.</span><span class="n">apply_fit_transform</span><span class="p">(</span><span class="n">fit_model</span><span class="p">)</span>
<span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span><span class="o">.</span><span class="n">plot</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span> <span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.3</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_108_0.png" src="_images/transforms_and_pipelines_108_0.png" />
</div>
</div>
<p>As a convenience, both <a class="reference internal" href="api.html#frankenfit.core.PipelineMember.then" title="frankenfit.core.PipelineMember.then"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">then()</span></code></span></a> and the addition
operator will automatically wrap their argument in an <code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code> if a
<code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> is provided, so we could also write our filtered Pipeline as:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">keep_large</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">(</span><span class="n">keep_large</span> <span class="o">+</span> <span class="n">fit_model</span><span class="p">);</span>  <span class="c1"># or equivalently: keep_large.then(fit_model)</span>
</pre></div>
</div>
</div>
</div>
<p>If we visualize this Pipeline, we can see the resulting <code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code> transform:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">keep_large</span> <span class="o">+</span> <span class="n">fit_model</span><span class="p">)</span><span class="o">.</span><span class="n">visualize</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<img alt="_images/transforms_and_pipelines_112_0.svg" src="_images/transforms_and_pipelines_112_0.svg" /></div>
</div>
<p>Earlier we mentioned a common use-case in which we have one or more predictive
pipelines, and one or more “scoring” methods, which we’d like to mix and match with each
other. This is another situation in which <code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code> is handy, because we might
want to fit the predictions on one dataset (training data) and apply and score them on
another dataset (test data). Let’s revisit out <code class="docutils literal notranslate"><span class="pre">combined_model</span></code> from before, and define
two scoring pipelines, one based on correlation and the other based on mean squared
error:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># predictive pipeline (a Transform)</span>
<span class="n">combined_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">prepare_training_response</span> <span class="o">+</span> <span class="n">prepare_features</span> <span class="o">+</span> <span class="n">predict_price</span><span class="p">)</span>

<span class="c1"># scoring pipelines</span>
<span class="n">score_corr</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span><span class="o">.</span><span class="n">correlation</span><span class="p">([</span><span class="s2">&quot;price_hat&quot;</span><span class="p">],</span> <span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">])</span>
<span class="n">score_mse</span> <span class="o">=</span> <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span><span class="o">.</span><span class="n">stateless_lambda</span><span class="p">(</span>
    <span class="k">lambda</span> <span class="n">df</span><span class="p">:</span> <span class="p">((</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;price_hat&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>One thing we could do is concatenate <code class="docutils literal notranslate"><span class="pre">combined_model</span></code> with each scoring pipeline, and
then fit the resulting Pipeline on <code class="docutils literal notranslate"><span class="pre">train_df</span></code> and apply it to <code class="docutils literal notranslate"><span class="pre">test_df</span></code> in order to get
the out-of-sample scores:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">combined_model</span> <span class="o">+</span> <span class="n">score_corr</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_hat</th>
      <td>0.925196</td>
    </tr>
  </tbody>
</table>
</div></div></div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="p">(</span><span class="n">combined_model</span> <span class="o">+</span> <span class="n">score_mse</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2376944.504049224
</pre></div>
</div>
</div>
</div>
<p>But that is wasteful, because we are fitting the pipeline every time that we wish to
score it. Thanks to <code class="docutils literal notranslate"><span class="pre">ApplyFitTransform</span></code> we can fit the predictive pipline just once,
giving us a <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code>, which we concatenate with the scoring pipelines, and apply
the result to <code class="docutils literal notranslate"><span class="pre">test_df</span></code> to compute the out-of-sample scores. In this way we avoid
re-fitting the Pipeline each time:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># now we only fit the model once</span>
<span class="n">fit_model</span> <span class="o">=</span> <span class="n">combined_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">display</span><span class="p">(</span>
    <span class="p">(</span><span class="n">fit_model</span> <span class="o">+</span> <span class="n">score_corr</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">),</span>
    <span class="p">(</span><span class="n">fit_model</span> <span class="o">+</span> <span class="n">score_mse</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_hat</th>
      <td>0.925196</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2376944.504049224
</pre></div>
</div>
</div>
</div>
<p>We can even include our <code class="docutils literal notranslate"><span class="pre">keep_large</span></code> filtering pipeline from before to get out-of-sample scores on only the largest diamonds (having fit on <em>all</em> sizes of diamonds):</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># still using the same fit from before</span>
<span class="n">display</span><span class="p">(</span>
    <span class="p">(</span><span class="n">keep_large</span> <span class="o">+</span> <span class="n">fit_model</span> <span class="o">+</span> <span class="n">score_corr</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">),</span>
    <span class="p">(</span><span class="n">keep_large</span> <span class="o">+</span> <span class="n">fit_model</span> <span class="o">+</span> <span class="n">score_mse</span><span class="p">)</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">test_df</span><span class="p">),</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_html"><div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>price</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>price_hat</th>
      <td>0.797287</td>
    </tr>
  </tbody>
</table>
</div></div><div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>6314941.902165627
</pre></div>
</div>
</div>
</div>
</section>
<section id="tagging-and-selecting-transforms">
<span id="tagging-selecting-transforms"></span><h3>Tagging and selecting transforms<a class="headerlink" href="#tagging-and-selecting-transforms" title="Permalink to this headline">#</a></h3>
<p>As mentioned <a class="reference internal" href="#transform-tags"><span class="std std-ref">above</span></a>, every <code class="docutils literal notranslate"><span class="pre">Transform</span></code> has an optional
<a class="reference internal" href="api.html#frankenfit.Transform.tag" title="frankenfit.Transform.tag"><span class="xref myst py py-attr"><code class="docutils literal notranslate"><span class="pre">tag</span></code></span></a> parameter, which determines the
<a class="reference internal" href="api.html#frankenfit.Transform.name" title="frankenfit.Transform.name"><span class="xref myst py py-attr"><code class="docutils literal notranslate"><span class="pre">name</span></code></span></a> of the <code class="docutils literal notranslate"><span class="pre">Transform</span></code> instance. The purpose of <code class="docutils literal notranslate"><span class="pre">name</span></code>
is to make it more convenient to identify and select individual <code class="docutils literal notranslate"><span class="pre">Transforms</span></code> when
embedded in larger <code class="docutils literal notranslate"><span class="pre">Pipelines</span></code>. For example, revisiting the <code class="docutils literal notranslate"><span class="pre">combined_model</span></code> from the
previous sections, we might add a custom tag like <code class="docutils literal notranslate"><span class="pre">&quot;price_regression&quot;</span></code> to the
<code class="docutils literal notranslate"><span class="pre">sk_learn()</span></code> Transform that performs the linear regression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">predict_price_tagged</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">ff</span><span class="o">.</span><span class="n">DataFramePipeline</span><span class="p">()</span>
    <span class="o">.</span><span class="n">sk_learn</span><span class="p">(</span>
        <span class="n">sklearn_class</span><span class="o">=</span><span class="n">LinearRegression</span><span class="p">,</span>
        <span class="n">x_cols</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;carat&quot;</span><span class="p">,</span> <span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="s2">&quot;depth&quot;</span><span class="p">],</span>
        <span class="n">response_col</span><span class="o">=</span><span class="s2">&quot;price_train&quot;</span><span class="p">,</span>
        <span class="n">hat_col</span><span class="o">=</span><span class="s2">&quot;price_hat&quot;</span><span class="p">,</span>
        <span class="n">class_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;fit_intercept&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">},</span>
        <span class="n">tag</span><span class="o">=</span><span class="s2">&quot;price_regression&quot;</span>  <span class="c1"># &lt;---</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">pipe</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">expm1</span><span class="p">,</span> <span class="s2">&quot;price_hat&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<p>The resulting <a class="reference internal" href="api.html#frankenfit.dataframe.SKLearn" title="frankenfit.dataframe.SKLearn"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">SKLearn</span></code></span></a> <code class="docutils literal notranslate"><span class="pre">Transform</span></code> object will have the
name <code class="docutils literal notranslate"><span class="pre">&quot;SKLearn#price_regression&quot;</span></code>, and with this tagged Transform in our
<code class="docutils literal notranslate"><span class="pre">combined_model</span></code>, we can now pull it back out for inspection by using the method
<a class="reference internal" href="api.html#frankenfit.core.PipelineMember.find_by_name" title="frankenfit.core.PipelineMember.find_by_name"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">find_by_name()</span></code></span></a>:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">combined_model</span> <span class="o">=</span> <span class="p">(</span><span class="n">prepare_training_response</span> <span class="o">+</span> <span class="n">prepare_features</span> <span class="o">+</span> <span class="n">predict_price_tagged</span><span class="p">)</span>
<span class="n">combined_model</span><span class="o">.</span><span class="n">find_by_name</span><span class="p">(</span><span class="s2">&quot;SKLearn#price_regression&quot;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>SKLearn(tag=&#39;price_regression&#39;, sklearn_class=&lt;class &#39;sklearn.linear_model._base.LinearRegression&#39;&gt;, x_cols=[&#39;carat&#39;, &#39;table&#39;, &#39;depth&#39;], response_col=HPFmtStr(name=&#39;price_train&#39;), hat_col=HPFmtStr(name=&#39;price_hat&#39;), class_params={&#39;fit_intercept&#39;: True}, w_col=&#39;&#39;)
</pre></div>
</div>
</div>
</div>
<p>The <a class="reference internal" href="api.html#frankenfit.FitTransform" title="frankenfit.FitTransform"><span class="xref myst py py-class"><code class="docutils literal notranslate"><span class="pre">FitTransform</span></code></span></a> class also provides a similar
<a class="reference internal" href="api.html#frankenfit.core.PipelineMember.find_by_name" title="frankenfit.core.PipelineMember.find_by_name"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">find_by_name()</span></code></span></a> method, which searches
through the <a class="reference internal" href="api.html#frankenfit.FitTransform.state" title="frankenfit.FitTransform.state"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">state()</span></code></span></a> of the <code class="docutils literal notranslate"><span class="pre">FitTransform</span></code>. This means
that after fitting the <code class="docutils literal notranslate"><span class="pre">combined_model</span></code> Pipeline on some data, which yields a
<code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> representing the state of the entire fit Pipeline, we can easily pull out
the sub-<code class="docutils literal notranslate"><span class="pre">FitTransform</span></code> corresponding to the regression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_model</span> <span class="o">=</span> <span class="n">combined_model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_df</span><span class="p">)</span>
<span class="n">fit_regression</span> <span class="o">=</span> <span class="n">fit_model</span><span class="o">.</span><span class="n">find_by_name</span><span class="p">(</span><span class="s2">&quot;SKLearn#price_regression&quot;</span><span class="p">)</span>
<span class="n">fit_regression</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>FitDataFrameTransform(resolved_transform=SKLearn(tag=&#39;price_regression&#39;, sklearn_class=&lt;class &#39;sklearn.linear_model._base.LinearRegression&#39;&gt;, x_cols=[&#39;carat&#39;, &#39;table&#39;, &#39;depth&#39;], response_col=&#39;price_train&#39;, hat_col=&#39;price_hat&#39;, class_params={&#39;fit_intercept&#39;: True}, w_col=&#39;&#39;), state=&lt;class &#39;sklearn.linear_model._base.LinearRegression&#39;&gt;, bindings={})
</pre></div>
</div>
</div>
</div>
<p>This is useful, for example, if we want to inspect the estimated betas of the regression:</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">fit_regression</span><span class="o">.</span><span class="n">state</span><span class="p">()</span><span class="o">.</span><span class="n">coef_</span>  <span class="c1"># coef_ attribute of sklearn.linear_model.LinearRegression</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([ 0.95536379, -0.03466946, -0.03150901])
</pre></div>
</div>
</div>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="footnote-if-fitting"><span class="brackets"><a class="fn-backref" href="#id2">1</a></span></dt>
<dd><p><em>Well actually,</em> the <code class="docutils literal notranslate"><span class="pre">Pipeline</span></code> base class does include
<a class="reference internal" href="api.html#frankenfit.Pipeline.then" title="frankenfit.Pipeline.then"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">then()</span></code></span></a>,
<a class="reference internal" href="api.html#frankenfit.Pipeline.apply_fit_transform" title="frankenfit.Pipeline.apply_fit_transform"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">apply_fit_transform()</span></code></span></a>, and
<a class="reference internal" href="api.html#frankenfit.Pipeline.if_fitting" title="frankenfit.Pipeline.if_fitting"><span class="xref myst py py-meth"><code class="docutils literal notranslate"><span class="pre">if_fitting()</span></code></span></a>, which act as call-chain methods,
though not specific to any particular data operations.</p>
</dd>
</dl>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>
        </article>
      </div>
      <footer>
        
        <div class="related-pages">
          <a class="next-page" href="hyperparams.html">
              <div class="page-info">
                <div class="context">
                  <span>Next</span>
                </div>
                <div class="title">Hyperparameters</div>
              </div>
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
            </a>
          <a class="prev-page" href="synopsis.html">
              <svg class="furo-related-icon"><use href="#svg-arrow-right"></use></svg>
              <div class="page-info">
                <div class="context">
                  <span>Previous</span>
                </div>
                
                <div class="title">Synopsis and overview</div>
                
              </div>
            </a>
        </div>
        <div class="bottom-of-page">
          <div class="left-details">
            <div class="copyright">
                Copyright &#169; 2023, Max Bane
            </div>
            Made with <a href="https://www.sphinx-doc.org/">Sphinx</a> and <a class="muted-link" href="https://pradyunsg.me">@pradyunsg</a>'s
            
            <a href="https://github.com/pradyunsg/furo">Furo</a>
            
          </div>
          <div class="right-details">
            <div class="icons">
              <a class="muted-link " href="https://pypi.org/project/frankenfit" aria-label="PyPI"><span id="snake">🐍</span></a>
              <a class="muted-link " href="https://github.com/maxbane/frankenfit" aria-label="GitHub"><svg stroke="currentColor" fill="currentColor" stroke-width="0" viewBox="0 0 16 16"> <path fill-rule="evenodd" d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0 0 16 8c0-4.42-3.58-8-8-8z"></path> </svg></a>
              
            </div>
          </div>
        </div>
        
      </footer>
    </div>
    <aside class="toc-drawer">
      
      
      <div class="toc-sticky toc-scroll">
        <div class="toc-title-container">
          <span class="toc-title">
            On this page
          </span>
        </div>
        <div class="toc-tree-container">
          <div class="toc-tree">
            <ul>
<li><a class="reference internal" href="#">Transforms and pipelines</a><ul>
<li><a class="reference internal" href="#transforms">Transforms</a><ul>
<li><a class="reference internal" href="#parameters">Parameters</a><ul>
<li><a class="reference internal" href="#tags">Tags</a></li>
</ul>
</li>
<li><a class="reference internal" href="#abstract-descriptions-and-immutability">Abstract descriptions and immutability</a></li>
<li><a class="reference internal" href="#stateless-transforms">Stateless transforms</a></li>
</ul>
</li>
<li><a class="reference internal" href="#pipelines">Pipelines</a><ul>
<li><a class="reference internal" href="#composing-transforms">Composing transforms</a></li>
<li><a class="reference internal" href="#pipeline-transforms">Pipeline transforms</a></li>
<li><a class="reference internal" href="#the-call-chain-api">The call-chain API</a></li>
<li><a class="reference internal" href="#fit-and-apply-in-one-go-pipeline-apply">Fit-and-apply in one go: <code class="docutils literal notranslate"><span class="pre">Pipeline.apply()</span></code></a></li>
<li><a class="reference internal" href="#visualizing-pipelines">Visualizing pipelines</a></li>
<li><a class="reference internal" href="#concatenating-pipelines">Concatenating pipelines</a><ul>
<li><a class="reference internal" href="#other-uses-of-then">Other uses of <code class="docutils literal notranslate"><span class="pre">then()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#including-fittransforms-in-a-pipeline">Including <code class="docutils literal notranslate"><span class="pre">FitTransforms</span></code> in a pipeline</a></li>
<li><a class="reference internal" href="#tagging-and-selecting-transforms">Tagging and selecting transforms</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          </div>
        </div>
      </div>
      
      
    </aside>
  </div>
</div><script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script src="_static/scripts/furo.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    </body>
</html>